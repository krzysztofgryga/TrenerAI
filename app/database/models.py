"""
SQLAlchemy models for TrenerAI.

Tables:
- users: User accounts (Trainer or Client role)
- client_profiles: Physical data for clients
- trainer_clients: Trainer-Client relationships
- groups: Client groups (managed by trainers)
- group_members: Group membership
- generated_trainings: Training plans generated by AI
- feedback: User feedback on generated trainings
"""
from datetime import datetime
from typing import Optional, List
from sqlalchemy import (
    Column, Integer, String, Float, DateTime, Boolean,
    ForeignKey, Text, JSON, Enum as SQLEnum, Table
)
from sqlalchemy.orm import relationship
from app.database.connection import Base
import enum


# =============================================================================
# ENUMS
# =============================================================================

class UserRole(str, enum.Enum):
    """User role in the system."""
    TRAINER = "trainer"
    CLIENT = "client"


class DifficultyLevel(str, enum.Enum):
    """Training difficulty level."""
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"


# =============================================================================
# USER & AUTHENTICATION
# =============================================================================

class User(Base):
    """
    User account - can be Trainer or Client.

    Trainer: manages clients, creates trainings, views all their clients' data
    Client: sees only own data, can generate trainings if allowed
    """
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    name = Column(String(255), nullable=False)

    # Role determines access level (use native_enum=False to store as VARCHAR)
    role = Column(
        SQLEnum(UserRole, values_callable=lambda obj: [e.value for e in obj]),
        default=UserRole.CLIENT.value,
        nullable=False
    )

    # Account status
    is_active = Column(Boolean, default=True, nullable=False)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    # If user is CLIENT - their profile
    client_profile = relationship("ClientProfile", back_populates="user", uselist=False)

    # If user is TRAINER - their clients
    clients = relationship(
        "TrainerClient",
        foreign_keys="TrainerClient.trainer_id",
        back_populates="trainer"
    )

    # If user is CLIENT - their trainers
    trainers = relationship(
        "TrainerClient",
        foreign_keys="TrainerClient.client_id",
        back_populates="client"
    )

    # If user is TRAINER - their groups
    owned_groups = relationship("Group", back_populates="trainer")

    # If user is CLIENT - group memberships
    group_memberships = relationship("GroupMember", back_populates="client")

    # Trainings (both roles can have)
    trainings = relationship(
        "GeneratedTraining",
        foreign_keys="GeneratedTraining.user_id",
        back_populates="user"
    )

    # Chat history
    chat_messages = relationship("ChatMessage", back_populates="user", order_by="ChatMessage.created_at")

    def __repr__(self):
        return f"<User(id={self.id}, email='{self.email}', role={self.role.value})>"

    @property
    def is_trainer(self) -> bool:
        return self.role == UserRole.TRAINER

    @property
    def is_client(self) -> bool:
        return self.role == UserRole.CLIENT


# =============================================================================
# CLIENT PROFILE
# =============================================================================

class ClientProfile(Base):
    """
    Physical profile for clients.
    Separated from User to keep user table clean.
    Only clients have profiles (trainers don't need weight/height).
    """
    __tablename__ = "client_profiles"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), unique=True, nullable=False)

    # Physical data
    age = Column(Integer, nullable=True)
    weight = Column(Float, nullable=True)  # kg
    height = Column(Float, nullable=True)  # cm

    # Training preferences
    goals = Column(Text, nullable=True)  # Free text goals
    contraindications = Column(JSON, nullable=True)  # List of health issues
    preferred_difficulty = Column(
        SQLEnum(DifficultyLevel),
        default=DifficultyLevel.MEDIUM
    )

    # Notes from trainer
    trainer_notes = Column(Text, nullable=True)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="client_profile")

    def __repr__(self):
        return f"<ClientProfile(id={self.id}, user_id={self.user_id})>"


# =============================================================================
# TRAINER-CLIENT RELATIONSHIP
# =============================================================================

class TrainerClient(Base):
    """
    Many-to-many relationship between trainers and clients.
    A trainer can have many clients.
    A client can have multiple trainers (e.g., strength + nutrition).
    """
    __tablename__ = "trainer_clients"

    id = Column(Integer, primary_key=True, index=True)
    trainer_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    client_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)

    # Permissions
    can_generate_training = Column(Boolean, default=False)  # Can client generate own trainings?
    can_view_history = Column(Boolean, default=True)  # Can client see training history?

    # Status
    is_active = Column(Boolean, default=True)  # Is relationship active?

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    trainer = relationship("User", foreign_keys=[trainer_id], back_populates="clients")
    client = relationship("User", foreign_keys=[client_id], back_populates="trainers")

    def __repr__(self):
        return f"<TrainerClient(trainer_id={self.trainer_id}, client_id={self.client_id})>"


# =============================================================================
# GROUPS
# =============================================================================

class Group(Base):
    """
    Client group managed by a trainer.
    Examples: "Morning FBW", "Advanced Lifters", "Weight Loss Program"
    """
    __tablename__ = "groups"

    id = Column(Integer, primary_key=True, index=True)
    trainer_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)

    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)

    # Group settings
    is_active = Column(Boolean, default=True)
    max_members = Column(Integer, nullable=True)  # None = unlimited

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    trainer = relationship("User", back_populates="owned_groups")
    members = relationship("GroupMember", back_populates="group")

    def __repr__(self):
        return f"<Group(id={self.id}, name='{self.name}')>"


class GroupMember(Base):
    """
    Group membership - links clients to groups.
    """
    __tablename__ = "group_members"

    id = Column(Integer, primary_key=True, index=True)
    group_id = Column(Integer, ForeignKey("groups.id"), nullable=False, index=True)
    client_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)

    # When they joined
    joined_at = Column(DateTime, default=datetime.utcnow)

    # Status
    is_active = Column(Boolean, default=True)

    # Relationships
    group = relationship("Group", back_populates="members")
    client = relationship("User", back_populates="group_memberships")

    def __repr__(self):
        return f"<GroupMember(group_id={self.group_id}, client_id={self.client_id})>"


# =============================================================================
# TRAININGS
# =============================================================================

class GeneratedTraining(Base):
    """Training plan generated by AI."""
    __tablename__ = "generated_trainings"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True, index=True)

    # Who created this training (trainer for client, or client for themselves)
    created_by_id = Column(Integer, ForeignKey("users.id"), nullable=True, index=True)

    # If created for a group
    group_id = Column(Integer, ForeignKey("groups.id"), nullable=True, index=True)

    # Input parameters (what was requested)
    input_params = Column(JSON, nullable=False)

    # Generated plan (full LLM output)
    plan = Column(JSON, nullable=False)

    # Model metadata
    model_name = Column(String(100), nullable=True)
    prompt_version = Column(String(50), default="v1.0")

    # Retrieved context from Qdrant
    retrieved_exercises = Column(JSON, nullable=True)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    user = relationship("User", foreign_keys=[user_id], back_populates="trainings")
    created_by = relationship("User", foreign_keys=[created_by_id])
    group = relationship("Group")
    feedback = relationship("Feedback", back_populates="training", uselist=False)

    def __repr__(self):
        return f"<GeneratedTraining(id={self.id}, user_id={self.user_id})>"


# =============================================================================
# FEEDBACK
# =============================================================================

class Feedback(Base):
    """User feedback on generated training."""
    __tablename__ = "feedback"

    id = Column(Integer, primary_key=True, index=True)
    training_id = Column(
        Integer,
        ForeignKey("generated_trainings.id"),
        nullable=False,
        unique=True,
        index=True
    )

    # Rating (1-5 stars)
    rating = Column(Integer, nullable=False)

    # Optional comment
    comment = Column(Text, nullable=True)

    # Specific feedback fields
    was_too_hard = Column(Boolean, default=False)
    was_too_easy = Column(Boolean, default=False)
    exercises_liked = Column(JSON, nullable=True)
    exercises_disliked = Column(JSON, nullable=True)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    training = relationship("GeneratedTraining", back_populates="feedback")

    def __repr__(self):
        return f"<Feedback(id={self.id}, training_id={self.training_id}, rating={self.rating})>"


# =============================================================================
# CHAT HISTORY
# =============================================================================

class ChatMessage(Base):
    """
    Chat message history for AI conversations.
    Messages are grouped by user - each user has one conversation thread.
    """
    __tablename__ = "chat_messages"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)

    # Message role: "user" or "assistant"
    role = Column(String(20), nullable=False)

    # Message content
    content = Column(Text, nullable=False)

    # Timestamp
    created_at = Column(DateTime, default=datetime.utcnow, index=True)

    # Relationships
    user = relationship("User", back_populates="chat_messages")

    def __repr__(self):
        return f"<ChatMessage(id={self.id}, user_id={self.user_id}, role='{self.role}')>"
